import java.util.*;

public class DroneContest {
    /**
     * Given an array of participants (that starts their drones at a time given by drone.start (inclusive),
     * stops it at drone.end (exclusive) and goes at height drone.height),
     * output the heights changes for the use of Skeyes.
     *
     * The first drone takes off strictly somewhere after time 0.
     *
     *  The height changes must be as described on INGInious.
     *  Equivalently, as follows:
     *  - They must be ordered by time
     *  - The first height change must be at time 0, and at height 0.
     *  - The last height change must be at the time the last drone stops (and thus must be at height 0!)
     *  - Given two successive height changes A and B, the maximum height of any active drone between A.time (inclusive)
     *    and B.time (exclusive) is EXACTLY A.height (i.e. there exists a drone with this height active between these
     *    times). Moreover, A.height != B.height.
     */
    public static LinkedList<HeightChange> findHighest(Drone[] participants) {
        // TODO
        Drone [] startInc = participants.clone();
        Arrays.sort(startInc, new Comparator<Drone>() {
            @Override
            public int compare(Drone drone1, Drone drone2) {
                return drone1.start-drone2.start;
            }
        });

        Drone [] endInc = participants.clone();
        Arrays.sort(endInc, new Comparator<Drone>() {
            @Override
            public int compare(Drone drone1, Drone drone2) {
                return drone1.end-drone2.end; //bon sens?
            }
        });

        //TreeMap<K,V>
        TreeMap<Integer, Integer> RedBlackTree = new TreeMap<Integer, Integer>();

        //LinkedList that will be return
        LinkedList<HeightChange> result = new LinkedList<>();

        result.add(new HeightChange(0,0)); //in the question drone started at t=1
        int previousHeight = result.get(0).height;

        int currentHeight;
        int i = 0; //Runner for startInc
        int j = 0; //Runner for endInc

        //bonne condition pas plutot &&
        while(i < startInc.length || j < endInc.length){
            int startTime = -1;
            int endTime = -1;
            //always??
            if (i < startInc.length) startTime = startInc[i].start;
            if (j < endInc.length) endTime = endInc[j].end;
            //add new elements in the RedBlackTree that will exist in the next interval
            if (startTime <= endTime) {
                while (i < participants.length && startInc[i].start == startTime) {
                    //check if height already exist in RedBlackTree
                    Integer count = RedBlackTree.get(startInc[i].height);
                    if (count == null) RedBlackTree.put(startInc[i].height, 1); //doesn't exist
                    else RedBlackTree.put(startInc[i].height, count + 1); //exist
                    i++;
                }
            }
            //remove all elements of the RedBlackTree that will not exist in the next interval
            if (endTime <= startTime) {
                while (j < participants.length && endTime == endInc[j].end) {
                    Integer count = RedBlackTree.get(endInc[j].height);
                    if (count.equals(1)) RedBlackTree.remove(endInc[j].height);
                    else RedBlackTree.put(endInc[j].height, count - 1);
                    j++;
                }
            }
            if (!RedBlackTree.isEmpty()) currentHeight = RedBlackTree.lastKey();
            else currentHeight = 0; //case empty so 0 for sure

            if (currentHeight != previousHeight) {
                previousHeight = currentHeight;
                result.add(new HeightChange(Math.min(startTime, endTime), currentHeight));
            }

        }
        return result;
    }
}
